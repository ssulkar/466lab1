Algorithm C45(D, A, T, threshold);
begin // Step 1: check termination conditions
    if for all d ∈ D: class(d) = ci then
        create leaf node r;
        label(r) := ci;
        T := r;
    else if A = ∅ then
        c := find most frequent label(D);
        create leaf node r;
        label(r) := c;
    else //Step 2: select splitting attribute
        Ag := selectSplittingAttribute(A,D, threshold);
        if Ag = NULL then //no attribute is good for a split
            create leaf node r;
            label(r) := find most frequent label(D);
            T := r;
        else // Step 3: Tree Construction
            create tree node r;
            label(r) := Ag;
            foreach v ∈ dom(Ag) do
                Dv := {t ∈ D|t[Ag] = v};
                if Dv 6= ∅ then
                    C45(Dv, A − {Ag}, Tv); //recursive call
                    append Tv to r with an edge labeled v;
                endif
            endfor
        endif
    endif
end

function selectSplittingAttribute(A, D,threshold); //uses information gain
begin
    p0 := enthropy(D);
    for each Ai ∈ A do
        p[Ai] := enthropyAi
        (D);
        Gain[Ai] = p0 − p[Ai]; //compute info gain
    endfor
    best := arg(findMax(Gain[]));
    if Gain[best] >threshold then return best
    else return NULL;
end

function selectSplittingAttribute(A, D,threshold); //uses information gain ratio
begin
    p0 := enthropy(D);
    for each Ai ∈ A do
        p[Ai] := enthropyAi
        (D);
        Gain[Ai] := p0 − p[Ai]; //compute info gain
        gainRatio[Ai] := Gain[Ai]/enthropy(Ai); //compute info gain ratio
    endfor
    best := arg(findMax(gainRatio[]));
    if Gain[best] >threshold then return best
    else return NULL;
end
